<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Updated Title to v10 -->
    <title>[SECURE] FORENSIC DATA ANALYZER V10.0</title>
    <style>
        /* --- CSS VARIABLES (Hacker Theme) --- */
        :root {
            --color-hacker-bg: #0a0a0a; /* Hitam Sangat Gelap */
            --color-hacker-text: #00ff41; /* Hijau Neon (Matrix) */
            --color-hacker-secondary: #00ffff; /* Cyan Neon */
            --color-hacker-error: #ff0041; /* Merah Neon */
            --color-hacker-warning: #ffff00; /* Kuning Neon */
            --color-hacker-shadow: 0 0 5px rgba(0, 255, 65, 0.5), 0 0 10px rgba(0, 255, 65, 0.2);
            --font-monospace: "Consolas", "Monaco", "Courier New", monospace;
            --transition-speed: 0.3s;
        }

        /* Global Reset and Hacker Look (Same as V9) */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: 16px; }
        body {
            font-family: var(--font-monospace); line-height: 1.4;
            background-color: var(--color-hacker-bg); color: var(--color-hacker-text);
            padding: 10px; min-height: 100vh;
        }

        .container {
            max-width: 900px; width: 100%; margin: 20px auto;
            background-color: #1a1a1a; padding: 25px; border-radius: 0;
            border: 1px solid var(--color-hacker-text); box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
            overflow: hidden;
        }

        h1, h2 {
            color: var(--color-hacker-secondary); text-shadow: 0 0 3px rgba(0, 255, 255, 0.7);
            border-bottom: 1px solid var(--color-hacker-text); padding-bottom: 8px;
            margin-bottom: 20px; text-transform: uppercase;
        }
        h1 { font-size: 1.8rem; }
        h2 { font-size: 1.4rem; margin-top: 30px; }

        .drop-area { /* ... D&D area styles (Same as V9) ... */
             border: 2px dashed var(--color-hacker-text); border-radius: 4px; padding: 30px;
             text-align: center; transition: all var(--transition-speed) ease; position: relative;
             margin-bottom: 20px; background-color: #0d0d0d;
        }
        .file-label { /* ... File label styles (Same as V9) ... */
             display: block; margin-bottom: 0; font-weight: 600; cursor: pointer;
             background-color: var(--color-hacker-secondary); color: var(--color-hacker-bg);
             padding: 12px 18px; border-radius: 4px; text-align: center;
             transition: background-color var(--transition-speed) ease; border: none;
        }
        #fileInput { display: none; }
        #outputArea { margin-top: 20px; min-height: 50px; }

        /* Status/Error Styling (Same as V9) */
        .status-message {
            font-weight: 600; padding: 12px 15px; border-radius: 0; margin-bottom: 20px;
            border: 1px dashed; text-align: center; text-transform: uppercase;
        }
        .status-message.processing { background-color: #222; color: var(--color-hacker-secondary); border-color: var(--color-hacker-secondary); }
        .status-message.error { background-color: #300a0a; color: var(--color-hacker-error); border-color: var(--color-hacker-error); }
        .status-message.warning { background-color: #30300a; color: var(--color-hacker-warning); border-color: var(--color-hacker-warning); }
        .status-message.success { background-color: #0a300a; color: var(--color-hacker-text); border-color: var(--color-hacker-text); }

        /* Code and output styles */
        #fileInfo code, #dataUrlOutput {
            background-color: #1f1f1f; padding: 3px 6px; border-radius: 2px;
            border: 1px solid #333; font-family: var(--font-monospace);
            word-break: break-all; font-size: 0.9em; color: var(--color-hacker-warning);
            text-shadow: none; display: inline-block; max-width: 100%; white-space: pre-wrap;
        }
        #fileInfo code.hash {
            font-size: 0.8em; /* Smaller font for long hashes */
            white-space: normal;
        }
        #dataUrlOutput {
             display: block; width: 100%; min-height: 150px; max-height: 400px; padding: 10px; margin-top: 10px; resize: vertical;
             color: var(--color-hacker-text);
        }

        /* Button Styles (Same as V9) */
        .action-button {
            color: var(--color-hacker-bg); background-color: var(--color-hacker-text);
            border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; margin-top: 12px;
            font-weight: 700; margin-right: 10px; text-transform: uppercase;
        }
        .action-button:hover { background-color: var(--color-hacker-secondary); box-shadow: 0 0 5px var(--color-hacker-secondary); color: var(--color-hacker-bg); }
    </style>
</head>
<body>

    <div class="container">
        <h1>DATA INJECTION & FORENSIC ANALYZER V10.0</h1>

        <div id="dropArea" class="drop-area">
            <label for="fileInput" class="file-label">>> INJECT TARGET DATA (INITIATE FILE STREAM)</label>
            <input type="file" id="fileInput">
            <p class="drop-text">atau SERET & LEPAS payload di sini</p>
        </div>

        <div id="outputArea">
            <p>STATUS: AWAITING INPUT. SILAKAN INJECT FILE DATA.</p>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log(":: STARTING FORENSIC ANALYZER V10.0 SEQUENCE ::");

            // --- Variabel dan Konstanta ---
            const fileInput = document.getElementById('fileInput');
            const outputArea = document.getElementById('outputArea');
            const dropArea = document.getElementById('dropArea');
            const MAX_FILE_SIZE_MB = 50;
            const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
            let currentBlobUrl = null;
            let currentFileNameForBlob = 'PAYLOAD_DOWNLOAD';

            // --- Validasi & Event Listeners (Same as V9) ---
            if (!fileInput || !outputArea || !dropArea) {
                console.error(":: FATAL ERROR: CRITICAL UI ELEMENTS MISSING ::");
                if (outputArea) { outputArea.innerHTML = '<div class="status-message error">:: CRITICAL ERROR! REBOOT SYSTEM ::</div>'; }
                return;
            }
            fileInput.addEventListener('change', (event) => { processFile(event.target.files); event.target.value = null; });
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => { dropArea.addEventListener(eventName, preventDefaults, false); });
            ['dragenter', 'dragover'].forEach(eventName => { dropArea.addEventListener(eventName, highlight, false); });
            ['dragleave', 'drop'].forEach(eventName => { dropArea.addEventListener(eventName, unhighlight, false); });
            dropArea.addEventListener('drop', handleDrop, false);

            function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
            function highlight() { dropArea.classList.add('highlight'); }
            function unhighlight() { dropArea.classList.remove('highlight'); }
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                processFile(files);
            }
            console.log(":: INPUT LISTENER ENABLED ::");

            // --- Fungsi Utama Handler File ---
            function processFile(fileList) {
                console.log(":: EXECUTING PROCESS_FILE FUNCTION ::");
                revokeCurrentBlobUrl();
                outputArea.innerHTML = '<div class="status-message processing">:: INITIATING DATA SEQUENCE. ANALYZING PAYLOAD... ::</div>';

                const file = fileList[0];

                if (!file) {
                    outputArea.innerHTML = '<p>STATUS: AWAITING INPUT. TIDAK ADA PAYLOAD YANG DIINJECT.</p>';
                    return;
                }
                currentFileNameForBlob = file.name;

                if (file.size > MAX_FILE_SIZE_BYTES) {
                    const errorMsg = `WARNING: PAYLOAD OVERSIZE (${formatBytes(file.size)}). MAX LIMIT ${MAX_FILE_SIZE_MB} MB. ABORTING FULL READ.`;
                    const warningDiv = document.createElement('div');
                    warningDiv.className = 'status-message warning';
                    warningDiv.textContent = errorMsg;
                    outputArea.innerHTML = '';
                    outputArea.appendChild(warningDiv);
                    // Pass the file even if oversized to still get metadata
                    displayFileInfo(file).then(infoDiv => { if (infoDiv) outputArea.appendChild(infoDiv); });
                    return;
                }

                outputArea.querySelectorAll(':not(.status-message)').forEach(el => el.remove());

                // displayFileInfo is now ASYNC but still part of Promise.all
                Promise.all([
                    displayFileInfo(file),
                    readFileAsDataURLPromise(file),
                    readFileForPreviewPromise(file)
                ]).then(([infoDiv, dataUrlResult, previewResult]) => {
                    console.log(":: DATA ANALYSYS COMPLETE. RENDERING OUTPUT ::");
                    const statusMsg = outputArea.querySelector('.status-message.processing');
                    if (statusMsg) statusMsg.remove();

                    if (infoDiv) outputArea.appendChild(infoDiv);
                    if (dataUrlResult) {
                        outputArea.appendChild(dataUrlResult);
                        const copyBtn = dataUrlResult.querySelector('#copyDataUrlButton');
                        const blobBtn = dataUrlResult.querySelector('#createBlobLinkButton');
                        if (copyBtn) copyBtn.addEventListener('click', handleCopyDataUrl);
                        if (blobBtn) blobBtn.addEventListener('click', handleCreateBlobLink);
                    }
                    if (previewResult) outputArea.appendChild(previewResult);

                }).catch(error => {
                    console.error(":: FATAL ERROR DURING DATA SEQUENCE:", error);
                    const statusMsg = outputArea.querySelector('.status-message');
                    const errorText = `FATAL ERROR: ${error.message || 'FAILED TO PROCESS DATA STREAM.'}`;
                    if (statusMsg && statusMsg.classList.contains('processing')) {
                       statusMsg.textContent = errorText;
                       statusMsg.className = 'status-message error';
                    } else {
                        outputArea.innerHTML = `<div class="status-message error">${errorText}</div>`;
                    }
                });
            }

            // --- HELPER BARU: Get SHA-256 Hash ---
            async function calculateFileHash(file) {
                if (!crypto.subtle || !file.arrayBuffer) return 'CRYPTO API UNAVAILABLE';
                try {
                    // Read file as ArrayBuffer
                    const buffer = await file.arrayBuffer();
                    // Calculate SHA-256 hash
                    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                    // Convert buffer to hex string
                    const hashArray = Array.from(new Uint8Array(hashBuffer));
                    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                } catch (e) {
                    console.error("HASH GENERATION ERROR:", e);
                    return 'HASH FAILED: ' + (e.message || 'UNKNOWN ERROR');
                }
            }

            // --- HELPER BARU: Read Magic Bytes (First 16 bytes) ---
            function readMagicBytes(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    // Read only the first 16 bytes slice
                    const slice = file.slice(0, 16);
                    reader.onload = function(event) {
                        if (event.target.result) {
                            const view = new DataView(event.target.result);
                            let hexString = '';
                            // Convert bytes to two-digit hex with spaces for readability
                            for (let i = 0; i < view.byteLength; i++) {
                                hexString += view.getUint8(i).toString(16).padStart(2, '0');
                                if ((i + 1) % 4 === 0 && i !== view.byteLength - 1) hexString += ' ';
                            }
                            resolve(hexString.toUpperCase());
                        } else {
                            resolve('READ FAILED: EMPTY RESULT');
                        }
                    };
                    reader.onerror = () => resolve('READ FAILED: IO ERROR');
                    reader.readAsArrayBuffer(slice);
                });
            }


            // --- Fungsi Pembacaan File (UPDATED: displayFileInfo is now ASYNC) ---

            function getFileCategory(mimeType) { // Same as V9
                if (!mimeType || mimeType.trim() === '') return 'RAW/UNKNOWN DATA';
                const lowerMime = mimeType.toLowerCase();

                if (lowerMime.startsWith('image/')) return 'GRAPHIC/IMAGE PROTOCOL';
                if (lowerMime.startsWith('video/')) return 'VIDEO/STREAM PROTOCOL';
                if (lowerMime.startsWith('audio/')) return 'AUDIO/WAVE PROTOCOL';
                if (lowerMime.startsWith('text/')) return 'ASCII/TEXT PROTOCOL';
                if (lowerMime.includes('application/pdf')) return 'SECURED PDF DOCUMENT';
                if (lowerMime.includes('application/zip') || lowerMime.includes('application/x-tar') || lowerMime.includes('application/gzip')) return 'ARCHIVE/COMPRESSED DATA';
                if (lowerMime.includes('json') || lowerMime.includes('xml')) return 'STRUCTURED DATA OBJECT';
                if (lowerMime.startsWith('application/')) return 'APPLICATION/BINARY PAYLOAD';
                return 'UNKNOWN DATA TYPE';
            }


            async function displayFileInfo(file) {
                 const fileInfoDiv = document.createElement('div');
                 fileInfoDiv.id = 'fileInfo';
                 fileInfoDiv.classList.add('section');

                 try {
                     // Perform async operations in parallel
                     const [fileHash, magicBytes] = await Promise.all([
                         calculateFileHash(file).catch(() => 'HASH_FAILURE'),
                         readMagicBytes(file).catch(() => 'MAGIC_BYTE_FAILURE')
                     ]);

                     // Sync Information
                     const extensionMatch = file.name.match(/\.([0-9a-z]+)$/i);
                     const fileExtension = extensionMatch ? extensionMatch[1].toUpperCase() : 'N/A';
                     const fileCategory = getFileCategory(file.type);
                     const lastModifiedTimestamp = file.lastModified;
                     
                     // Calculate Base64 Overhead (Approximate: 33.3% + padding)
                     const base64Overhead = ((file.size * 4 / 3) - file.size) / file.size * 100;
                     const overheadText = file.size > MAX_FILE_SIZE_BYTES ? `(OVERSIZE: CALCULATE FAILED)` : `${base64Overhead.toFixed(2)}%`;


                     fileInfoDiv.innerHTML = `
                         <h2>PAYLOAD METADATA</h2>
                         <p><strong>PAYLOAD NAME:</strong> <code>${escapeHtml(file.name)}</code></p>
                         <p><strong>FILE EXTENSION:</strong> <code>${escapeHtml(fileExtension)}</code></p>
                         <p><strong>DATA SIZE (BYTES):</strong> ${formatBytes(file.size)} (${file.size} bytes)</p>
                         <p><strong>MIME PROTOCOL:</strong> <code>${escapeHtml(file.type) || 'UNKNOWN'}</code></p>
                         <p><strong>DATA CATEGORY:</strong> ${fileCategory}</p>
                         
                         <p><strong>BASE64 OVERHEAD:</strong> ${overheadText}</p> <!-- NEW DETAIL -->
                         <p><strong>DATA HEADER (MAGIC BYTES):</strong> <code>${escapeHtml(magicBytes)}</code></p> <!-- NEW DETAIL -->

                         <h2>INTEGRITY CHECK [SHA-256]</h2>
                         <p><strong>DATA FINGERPRINT:</strong> <code class="hash">${escapeHtml(fileHash)}</code></p> <!-- NEW DETAIL (HASH) -->

                         <h2>SYSTEM TIMESTAMPS</h2>
                         <p><strong>LAST MODIFIED (LOCAL):</strong> ${file.lastModifiedDate ? file.lastModifiedDate.toLocaleString('id-ID') : 'N/A'}</p>
                         <p><strong>MODIFICATION EPOCH:</strong> <code>${lastModifiedTimestamp || 'N/A'}</code></p>
                     `;
                     return fileInfoDiv;
                 } catch (e) {
                     console.error(":: ERROR IN METADATA EXTRACTION ::", e);
                     // Create error div for info section
                     fileInfoDiv.innerHTML = `<h2>PAYLOAD METADATA</h2><div class="status-message error">DATA EXTRACTION FAILED: ${escapeHtml(e.message)}</div>`;
                     return fileInfoDiv; // Still resolve with the error message in the div
                 }
            }

            // --- Fungsi Pembacaan Data URL, Pratinjau, dan Tombol (Same as V9) ---

            function readFileAsDataURLPromise(file) {
                 return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        if (!event.target || typeof event.target.result !== 'string' || !event.target.result.startsWith('data:')) {
                            reject(new Error("FAILED TO DECODE BASE64 STREAM.")); return;
                        }
                        const dataUrlSection = document.createElement('div');
                        dataUrlSection.id = 'dataUrlSection';
                        dataUrlSection.classList.add('section');
                        dataUrlSection.innerHTML = `
                            <h2>BASE64 DATA & LOCAL FORGE</h2>
                            <p>RAW BASE64 REPRESENTATION OF PAYLOAD. INJECT THIS STREAM DIRECTLY INTO CODE (e.g., <code><img src="...data:..."></code>) OR COPY FOR EXTERNAL USE.</p>
                            <textarea id="dataUrlOutput" readonly>${event.target.result}</textarea>
                            <button id="copyDataUrlButton" class="action-button">> COPY DATA STREAM</button>
                            <button id="createBlobLinkButton" class="action-button">> FORGE LOCAL BLOB (DOWNLOAD)</button>
                            <div id="blobUrlResultArea" aria-live="polite">
                            </div>
                        `;
                        resolve(dataUrlSection);
                    };
                    reader.onerror = (event) => { reject(new Error(`FAILED TO READ PAYLOAD: ${event.target.error.name || 'UNKNOWN ERROR'}`)); };
                    reader.onabort = () => { reject(new Error("DATA READ ABORTED BY SYSTEM.")); };
                    try { reader.readAsDataURL(file); }
                    catch (e) { reject(new Error("FAILED TO INITIATE BASE64 READ OPERATION.")); }
                });
            }

            function readFileForPreviewPromise(file) {
                 return new Promise((resolve, reject) => {
                    const previewSection = document.createElement('div');
                    previewSection.id = 'previewSection';
                    previewSection.classList.add('section');
                    previewSection.innerHTML = `<h2>PAYLOAD VISUALIZATION</h2>`;
                    const previewArea = document.createElement('div');
                    previewArea.id = 'previewArea';
                    previewSection.appendChild(previewArea);
                    const fileType = file.type;
                    const reader = new FileReader();

                    reader.onload = function(event) {
                          if (!event.target || typeof event.target.result === 'undefined') {
                              previewArea.innerHTML = '<p>VISUALIZATION FAILED. INVALID DATA STREAM.</p>';
                              resolve(previewSection); return;
                          }
                        let previewElement;
                        const result = event.target.result;
                        try {
                            if (fileType.startsWith('image/')) {
                                previewElement = document.createElement('img'); previewElement.src = result; previewElement.alt = `VISUALIZING ${escapeHtml(file.name)}`;
                                previewElement.onerror = () => { previewArea.innerHTML = '<p>FAILED TO LOAD GRAPHIC PROTOCOL.</p>'; };
                            } else if (fileType.startsWith('video/')) {
                                previewElement = document.createElement('video'); previewElement.src = result; previewElement.controls = true;
                                previewElement.onerror = () => { previewArea.innerHTML = '<p>FAILED TO INITIATE VIDEO STREAM.</p>'; };
                            } else if (fileType.startsWith('audio/')) {
                                previewElement = document.createElement('audio'); previewElement.src = result; previewElement.controls = true;
                                previewElement.onerror = () => { previewArea.innerHTML = '<p>FAILED TO INITIATE AUDIO WAVE.</p>'; };
                            } else if (fileType === 'text/html') {
                                previewElement = document.createElement('iframe'); previewElement.src = result; previewElement.sandbox = 'allow-same-origin'; previewElement.title = `HTML VIEW: ${escapeHtml(file.name)}`;
                                previewElement.onerror = () => { previewArea.innerHTML = '<p>HTML INJECTION BLOCKED (SAFETY PROTOCOL). VIEW RAW DATA.</p>'; };
                            } else if (fileType.startsWith('text/')) {
                                previewElement = document.createElement('pre'); previewElement.textContent = result;
                            } else {
                                previewArea.innerHTML = `<p>VISUALIZATION NOT SUPPORTED FOR PROTOCOL: <code>${escapeHtml(fileType) || 'UNKNOWN'}</code>.</p>`;
                                resolve(previewSection); return;
                            }
                            if (previewElement) { previewArea.appendChild(previewElement); }
                            resolve(previewSection);
                        } catch (e) {
                             previewArea.innerHTML = `<div class="status-message error">VISUALIZATION ERROR: ${escapeHtml(e.message)}</div>`;
                             resolve(previewSection);
                        }
                    };
                    reader.onerror = (event) => { previewArea.innerHTML = `<div class="status-message error">FAILED TO READ PAYLOAD FOR VISUALIZATION: ${escapeHtml(event.target.error.name || 'UNKNOWN ERROR')}</div>`; resolve(previewSection); };
                    reader.onabort = () => { previewArea.innerHTML = `<div class="status-message warning">PAYLOAD READ FOR VISUALIZATION ABORTED.</div>`; resolve(previewSection); };
                    try {
                        if (fileType.startsWith('image/') || fileType.startsWith('video/') || fileType.startsWith('audio/') || fileType === 'text/html') {
                            reader.readAsDataURL(file);
                        } else if (fileType.startsWith('text/')) {
                            reader.readAsText(file);
                        } else { resolve(previewSection); }
                    } catch (e) { reject(new Error("FAILED TO INITIATE VISUALIZATION READ OPERATION.")); }
                 });
            }

            function handleCopyDataUrl(event) {
                handleGenericCopy(event.target, '#dataUrlOutput', 'DATA STREAM COPIED', 'COPY DATA STREAM');
            }
            function handleCreateBlobLink(event) {
                const button = event.target; button.disabled = true;
                const section = button.closest('#dataUrlSection');
                const dataUrlOutput = section ? section.querySelector('#dataUrlOutput') : null;
                const blobResultArea = section ? section.querySelector('#blobUrlResultArea') : null;

                if (!dataUrlOutput || !blobResultArea) {
                    if(blobResultArea) blobResultArea.innerHTML = `<p class="status-message error">ACCESS DENIED / UI COMPONENT MISSING.</p>`;
                    button.disabled = false; return;
                }
                const dataUrl = dataUrlOutput.value;
                if (!dataUrl || !dataUrl.startsWith('data:')) {
                    blobResultArea.innerHTML = `<p class="status-message error">ERROR: INVALID BASE64 STREAM DETECTED.</p>`;
                    button.disabled = false; return;
                }
                blobResultArea.innerHTML = `<p class="status-message processing">:: FORGING LOCAL BLOB URL... ::</p>`;
                try {
                    const blob = dataURLtoBlob(dataUrl);
                    if (!blob) { throw new Error("FAILED TO RECONSTRUCT BINARY BLOB."); }
                    revokeCurrentBlobUrl();
                    currentBlobUrl = URL.createObjectURL(blob);
                    blobResultArea.innerHTML = `
                        <p class="status-message success">LOCAL BLOB FORGED. SECURE DOWNLOAD LINK ESTABLISHED.</p>
                        <p><strong>ALERT:</strong> THIS LOCAL BLOB URL IS EPHEMERAL! IT WILL EXPIRE ON TAB/BROWSER CLOSURE AND IS <strong>NON-TRANSFERABLE</strong>.</p>
                        <a href="${currentBlobUrl}" download="${escapeHtml(currentFileNameForBlob || 'payload_download')}" title="INITIATE BLOB DOWNLOAD">
                            >> DOWNLOAD PAYLOAD (${escapeHtml(currentFileNameForBlob || 'FILE')})
                        </a>
                        <p><small>RAW URL (FOR DEBUG): <code>${currentBlobUrl}</code></small></p>
                    `;
                } catch (error) {
                    revokeCurrentBlobUrl();
                    blobResultArea.innerHTML = `<p class="status-message error">FAILED TO FORGE BLOB: ${escapeHtml(error.message)}</p>`;
                } finally {
                     button.disabled = false;
                }
            }

            function dataURLtoBlob(dataurl) {
                try {
                    const arr = dataurl.split(',');
                    if (arr.length < 2) return null;
                    const mimeMatch = arr[0].match(/:(.*?);/);
                    const mime = mimeMatch ? mimeMatch[1] : 'application/octet-stream';
                    const bstr = atob(arr[1]);
                    let n = bstr.length;
                    const u8arr = new Uint8Array(n);
                    while (n--) { u8arr[n] = bstr.charCodeAt(n); }
                    return new Blob([u8arr], { type: mime });
                } catch (e) { return null; }
            }

            function revokeCurrentBlobUrl() {
                if (currentBlobUrl) {
                    URL.revokeObjectURL(currentBlobUrl);
                    currentBlobUrl = null;
                     const blobResultArea = outputArea.querySelector('#blobUrlResultArea');
                     if (blobResultArea) { blobResultArea.innerHTML = ''; }
                }
            }

            function handleGenericCopy(button, selector, successMsg, originalMsg) {
                 const section = button.closest('.section');
                 const elementToCopyFrom = section ? section.querySelector(selector) : null;

                 if (elementToCopyFrom && navigator.clipboard && !button.disabled) {
                     copyToClipboard(elementToCopyFrom.value, button, successMsg, originalMsg);
                 } else if (!navigator.clipboard) {
                     alert('CLIPBOARD ACCESS DENIED. MANUAL DATA EXTRACTION REQUIRED.');
                 }
            }

            function copyToClipboard(textToCopy, buttonElement, successMsg, originalMsg) {
                if (!textToCopy) { return; }
                navigator.clipboard.writeText(textToCopy).then(() => {
                     buttonElement.textContent = successMsg;
                     buttonElement.disabled = true;
                     setTimeout(() => {
                         buttonElement.textContent = originalMsg;
                         buttonElement.disabled = false;
                     }, 2000);
                 }).catch(err => {
                     buttonElement.textContent = 'ACCESS DENIED!';
                     alert('CLIPBOARD FAILED. MANUAL DATA EXTRACTION REQUIRED.');
                 });
            }

            function formatBytes(bytes, decimals = 2) {
                if (!+bytes || bytes < 0) return '0 BYTES';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['BYTES', 'KB', 'MB', 'GB', 'TB', 'PB'];
                const i = bytes === 0 ? 0 : Math.floor(Math.log(bytes) / Math.log(k));
                const index = Math.max(0, Math.min(i, sizes.length - 1));
                const size = parseFloat((bytes / Math.pow(k, index)).toFixed(dm));
                return `${size} ${sizes[index]}`;
            }

            function escapeHtml(unsafe) {
                 if (typeof unsafe !== 'string') { return String(unsafe); }
                 return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }

            console.log(":: SYSTEM INITIALIZATION COMPLETE. STANDBY FOR COMMAND ::");

        });
    </script>

</body>
</html>
